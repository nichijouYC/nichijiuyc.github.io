---
title: JVM相关知识点总结
date: 2017-03-10 17:22:19
tags:
---


### JVM

#### 内存区域
1. java内存区域分为5类，分别是方法区、堆、虚拟机栈、本地方法栈和程序计数器
    - 所有线程共享：方法区、堆
    - 线程隔离：虚拟机栈、本地方法栈、程序计数器

2. 程序计数器：当前线程所执行字节码的行号，每条线程独立，不会抛出OutOfMemoryError错误

3. 虚拟机栈：线程私有，每个方法执行时会创建一个栈帧，里面存储**方法的局部变量表(GCROOT)，操作数栈**等。局部变量表放了编译时期可知的**基本数据类型和对象引用（对象地址）**。
    - 局部变量表在**编译期间完成分配**，运行期间不会改变大小。申请时无法申请足够内存会抛出OutOfMemoryError错误

4. 本地方法栈：存储nativa方法相关的对象(GCROOT)，虚拟机栈存储java方法相关

5. java堆：所有线程共享，虚拟机启动时创建，**存放对象实例**。是垃圾回收的主要管理区域，大小通过-Xmx 和 -Xms指定，会抛出OutOfMemoryError错误, -Xmn指定新生代大小

6. 方法区：所有线程共享，存储已经被虚拟机加载的**类信息，常量(GCROOT)，静态变量(GCROOT)**等数据，动态加载大量class时容易方法区溢出
运行时常量池是方法区的一部分，存储常量信息
**jdk1,6常量池放在方法区（永久代），jdk1.7常量池放在堆内存，jdk1.8放在元空间里面，和堆相独立**

<!-- more -->

#### OOM
1. 堆溢出：不断new新的对象，并且保持引用，则使gc无法回收，造成OOM
2. 栈溢出: 不断递归，达到最大栈深度就（StackOverflowError） 通过-Xss设置栈大小.或者不断创建新的线程,线程数过多也会导致栈溢出
3. 方法区溢出：生成大量常量或者动态生成大量Class会造成方法区溢出 通过-XX:PermSize 和 -XX:MaxPermSize设置永久代大小间接设置方法区大小

- 内存溢出 out of memory，是指程序在申请内存时，超过系统能给的，没有足够的内存空间供其使用，出现out of memory （没有多余内存分配）    
- 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，new以后不delete，也许自己不能访问，系统也无法分配给别人。（分配以后没有回收）

#### gc算法
1. 垃圾回收 对象：java堆和方法区
    其他内存区域的内容在编译器已经确定大小，并且其他内存为线程私有的 等线程结束即可回收
2. 可达性分析来判断对象是否存活（java，C#）
	通过GCRoots的对象作为起点向下搜索，搜索走过的路径为引用链，当一个对象到GCRoots不可达时，则判断对象没有存活
3. 不同算法的主要思想:尽可能减少gc时间
3. 垃圾回收的三种算法
    1.  标记清除算法，该算法是从根集合扫描整个空间，标记存活的对象，然后在扫描整个空间对没有被标记的对象进行回收，这种算法在存活对象较多时比较高效，但会产生内存碎片。
    2. 复制算法，该算法是从根集合扫描，并将存活的对象复制到新的空间，每次只能使用一半的内存空间。这种算法在存活对象少时比较高效。
    3. 标记整理算法，标记整理算法和标记清除算法一样都会扫描并标记存活对象，在回收未标记对象的同时会整理被标记的对象，解决了内存碎片的问题。
    - 新生代：每次垃圾回收都有大量对象死去，少量存活，用复制算法，完成收集.因为使用复制算法,所以需要eden,from,to(servivor区)
    - 老年代：对象存活率高，使用标记-清理或标记-整理算法来回收
4. mirrorgc和fullgc
	- 对象首先在eden区分配,eden区分配不了时触发mirrorgc.把eden区和一块survivor存货的对象复制到另一个survivor.清空eden区
	- 当老年代放不下或者永久代满时触发fullgc,或者直接调用system.gc().会清理整个堆空间
5. 新生代对象什么条件会进入老年代
	1. 新生代中的大对象直接进入老年代(参数控制)
	2. 长期存活的对象(15age 经历过15次mirrorgc).
	3. minor gc后，survivor仍然放不下的对象
	4. 动态对象年龄判定,当survivor空间中相同年龄的对象达到空间一半,那大于这个年龄对象全部进入老年代

#### 垃圾回收器
1. serial垃圾回收器：在gc时会把用户线程全部暂停，单线程，有gc停顿，新生代收集器，可以和cms共用
2. ParNew收集器：serial的多线程版本，起多个gc线程，新生代收集器，可以和cms共用,适合用户交互的程序
3. Parallel Scavenge收集器：新生代收集器，多线程，更关注吞吐量，适合后台运算较多，用户交互较少的程序，有自适应调节策略，自动调节吞吐量，吞吐率=用户代码时间/（用户代码时间+GC时间）
4. serial old：老年代收集器，单线程，serial老年代版本
5. parallel old： Parallel Scavenge收集器老年代版本，如果要求吞吐量优先，则可以选择Parallel Scavenge+ parallel old
6. cms：老年代收集器，目标是最短停顿时间,不能和parallel scavenge收集器共用,因为一个追求最短停顿 一个追求吞吐量 两者矛盾 无法共用.
7. g1:大体采用标记-整理的算法,把整个堆分为多个大小相等的独立区域(region),优先回收价值最大的region

- 新生代收集器都是采用复制算法,老年代收集器除了cms其他都是标记整理,cms是标记清楚
- 注重吞吐量的后台程序一般采用parallel scavenge+parallel old垃圾回收器
- 注重响应时间的一般采用parnew+cms收集器
- 堆空间大于32G的一般采用g1收集器


#### 类加载步骤
类加载步骤

1. 加载(通过类的全名获取类二进制流,按照一定结构存储在方法区中,并在内存中生成java.lang.Class对象)
2. 连接
    1. 验证(验证一个类是不是合法,比如格式规范,需要jvm版本,是否继承了不允许继承的类,是否实现了父类所有的方法等)
    2. 准备(在方法区,为类变量(static修饰)分配内存并初始化值,0值)
    3. 解析(将符号引用替换成直接引用,直接引用的对象必须在内存中存在)
3. 初始化(执行类变量赋值/静态语句块等,从上往下,并且能保证父类的初始化先执行再执行子类的)(同一个类加载器只会初始化一次同一个类,并且同时只有一个线程执行类初始化,其他线程会阻塞)
4. 使用
5. 卸载

对象创建步骤

1. 类加载检查,new的时候看这个类是否被加载解析初始化过
2. 为新对象分配内存.因为对象所需大小在类加载时可以完全确定(除了数组对象),相当与在内存中把一整块大小空间划分出来
	1. 指针碰撞. 如果java堆中内存是整齐的,所有用过的内存都放在一边，未使用的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个.指针指向空闲空间那边挪动一段与对象大小相等的距离
	2. 空闲列表. 如果java堆中的内存并不是规整的，已使用的内存和未使用的内存相互交错，就无法使用指针碰撞了，虚拟机必须维护一个列表来记录哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例并更新表上的记录

#### 类加载器
作用:通过一个类的全名获取类二进制流
每个类加载器有独立的类名称空间,一个类可以通过加载它的类加载器和类全名唯一限定
系统类加载器

1. bootstrap加载器:加载java_home/lib目录中的类,比如rt.jar等(String Long Object类等等)
2. extension加载器:加载java_home/lib/ext目录下的类
3. Application加载器:加载用户的类 classpath

#### 双亲委派机制
1. 一个类A中引用到另一个类B,则由类A的类加载器进行加载,确保同一个类的引用都用同一个类加载器加载
2. 双亲委派机制：类加载器之间通过组合关系来实现，过程是：首先把类加载的请求委托给父类，当父类无法加载时，子类才会尝试去加载
3. 双亲委派机制的好处是一个公用类都会是真正的同一个类，比如Object，都由BootstrapClassLoader加载，所有程序都用的是同一个类.越是基础的类,越上层加载器加载
4. loadclass方法:首先检查类是否已经加载过,加载过直接返回这个类.如果没有加载过则调用父加载期的loadclass方法.如果父加载不了,则抛出classnotfoundexception,使用自身去加载.首先findclass方法读取字节流,在defineclass方法将字节流转换成class对象

破坏案例:
1. jdbc.JDBC作为java的标准服务，由BootStrapClassLoader加载，但是在jdbc调用实现代码时，bootstrapClassLoader却没能力加载实现的具体代码(比如mysql-jdbc.jar包放在classpath中)。所以使用了线程上下文加载器(Thread context ClassLoader)来代替bootstrapClassLoader对类进行加载，也就是父类请求子类完成加载任务，破坏了双亲委托模型
2. tomcat.WebAppClassLoader会优先加载应用下的Jar(web-inf)，而不是先委托给CommonClassLoader。不过原则上对于java.*的类，都优先向上委托。这样每个应用都有自己的类,不同应用的不同版本相同类不会冲突

#### 性能监控工具
1. jps: 显示java进程 jps -l  显示主类全名 jps -v 显示jvm启动的时候设置的参数
2. jstat: 显示jvm当前状态 jstat -gcutil pid 1000 每隔一秒打印java堆每个区已经占有的百分比
3. jmap:打印出jvm内存堆信息 jmap -dump:format=b,file=tes.hprof  pid  再导入eclipse或者jvisual 查看    检查内存溢出经常用
4. jstack: 打印出jvm栈/线程信息    jstack -l pid 检查线程死锁,夯住经常用

#### 内存模型
- 现代计算机的内存模型:
	1. 多核CPU
    2. 多个高速缓存Cache
    3. 一块主内存
- java内存模型:屏蔽各种硬件和操作系统对内存访问的差异.规定所有变量(线程共享的变量,不包括局部变量因为局部变量线程私有)存在主内存中,每个线程有自己的工作内存,工作内存保存了变量在主内存的副本.线程对变量的操作都在工作内存中进行,在付给主内存.线程间变量传递必须通过主内存进行

- 这样设计会引入缓存一致性问题.因为多个处理器有多个自己的高速缓存,当处理同一块主内存的数据时,可能各自的缓存数据不一致,需要遵循一致性协议

#### 线程与进程的区别
1. 进程是分配资源的基本单位，线程是独立运行和调度的单位
2. 每一个进程有自己的一整套变量，而线程则共享数据
3. 一个进程包含多个线程，可以共享进程拥有的资源

- 线程5种状态
    1. new: 创建以后还没有启动的状态
    2. runable:正在执行的状态和等待cpu的状态
    3. waiting:等待其他线程唤醒.比如Object.wait()方法 Thread.join()方法.不唤醒的话无限制等待
    4. timed waiting:等待一定时间后系统自动唤醒.Thread.sleep() 或者其他设置timeout的wait,join方法
    5. blocked:程序在等待进入synchronized同步区域,在等待一个锁时进入block状态
    6. terminated: 结束状态
    
#### 并发的三个性质
1. 原子性:表明该操作不能在被分割了 a=1.非原子性的都有可能线程不安全比如a=a+1.synchronized可以保证原子性
2. 可见性:当一个线程对值进行更改后,新值对于其他线程来说可以立即得知.volatile.final.synchronized可以保证可见性
3. 有序性:在本线程内所有操作都是有序的.volatitle和synchronized可以保证有序性.

#### volatile关键字
1. 可见性:当一个线程对值进行更改后,新值对于其他线程来说可以立即得知.每次使用volatile变量都会刷新.普通变量需要写会主内存,再从主内存读才能看见.但不代表volatile并发安全.实现:在汇编代码中加入lock指令,lock指令表示将当前处理器缓存行的数据会写回到系统内存。这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效
2. 禁止指令重排序.实现:通过插入内存屏障实现.在步骤之间插入内存屏障保证按序执行

- 应用场景:最适用一个线程写，多个线程读的场合,比如作为标志位
- 优缺点:优点是比sync轻量级,缺点是并不能保证线程安全在非原子操作中比如i++
