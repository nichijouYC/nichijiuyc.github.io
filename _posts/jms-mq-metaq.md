---
title: JMS消息规范和消息队列
date: 2017-07-10 23:02:19
tags:
---


## JMS消息规范

- JMS（Java Message Service,java消息服务， JSR 914），JMS的客户端之间可以通过JMS服务进行异步的消息传输。

- JMS是消息服务，只要对方收到消息即可，发送者不需要消费者的反馈

### 特点
- 松耦合，将发送者和消费者分离开
- 异步性，发送者不需要等待消费者响应
- 可靠性，发送失败的消息在中间件中保存，只有消费者收到确认以后才删除消息

<!-- more -->

### 消息模型
1. 点对点Point-to-Point(P2P)
2. 发布订阅Publish/Subscribe(Pub/Sub)

#### 点对点模型
- 每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)
- 接收者在成功接收消息之后需向队列应答成功
- 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列

#### Pub/Sub模型
- 每个消息可以有多个消费者
- 发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态（或者采用持久订阅模式）。

### 消息确认
- JMS定义了消息确认概念，消费者可以在收取一个消息时自动确认。也可以在一次会话过程，可以像jdbc那样，设置一个手动事务，处理完成后，提交，确认所有的消息
- 如果没有确认，JMS还会重试再次发送消息

### 消息持久化
- JMS定义了消息的持久化。内存放一份，持久化的介质中放一份。queue默认是持久化的。topic，因为要发送给多个人，默认是非持久化的（下线就收不到消息）。或者持久订阅（无论订阅者是否在线都能收到所有消息）

### 符合JMS规范需要实现的接口
- javax.jms.Message: 消息
- javax.jms.Queue: P2P模式的消息目的地
- javax.jms.Topic: 发布订阅模式的消息目的地
- javax.jms.ConnectionFactory: 创建连接的工厂
- javax.jms.Connection: 客户端到jms的活动连接
- javax.jms.Session: 发送和接受消息的单线程上下文
- javax.jms.MessageProducer: Session创建对象，用于发送消息到queue或者topic
- javax.jms.MessageConsumer: Session创建对象，用于接受queue或者topic

### JMS规范不包含的内容
- 负载均衡
- 容错等


## 消息队列的设计

- 使用mq的几个场景及解决方案
    1. 业务解耦
        - 基于消息的模型，关心的是通知 ，而不是处理，不关心处理结果
        - mq通过两次rpc，传递消息
    2. 广播消息
        - 将一个消息投递给下游多个业务方
        - 要实现广播消息，mq需要维护所有消费者信息。为了能自动感知消费者上下线，需要引入configserver配置中心
    3. 错峰控流
        - 解决上下游处理速度不对等的问题
        - 要实现错峰控流，应对消费者处理消息不及时的问题。需要将消息在mq中堆积，在合适的时候投递，需要将消息持久化存储

- ![消息队列设计][1]
- 关键问题的解决思路
    1. 可靠投递：保证可靠投递，必须要在发送消息时，先消息落地存储，再发送，等待结果。如果发生、消费失败或者不知道失败（超时），重发这个消息。要保证消息不丢。肯定会有消息重复的问题
    2. 重复消息：消费者做业务幂等或者消息去重
    3. 顺序消息：从发送方到服务方到接受者都是单点单线程。并且消费者来处理由网络引起的乱序问题，按照消息唯一key的顺序处理
    4. 慢消费：消费者用pull模型获取消息。因为消费者消费速度慢，由消费者主动向broker要数据来处理。如果用push模型的话，会把消费者撑爆。可以通过长轮询实现，保持broker和消费者的长连接

## metaq
- 支持严格的消息顺序
- 支持Topic与Queue两种模式
- 亿级消息堆积能力
- 比较友好的分布式特性
- 同时支持Push与Pull方式消费消息
- 所有的消息都是文件持久化的
- 另外，metaq并没有支持上面说的jms规范

### metaq架构图
![metaq架构图][2]

- producer集群：消息生产者集群
- nameserver集群：管理生产者，消费者，broker， 和维护路由关系
- consumer集群：消息消费者集群
- broker-master-slave：消息转发集群，并且有master、slave主从备份

### metaq发送和接受消息过程
- producer发送消息
![metaq-producer发送消息][3]
- broker接受消息
![metaq-broker接受消息][4]



        


  [1]: http://onobwtidg.bkt.clouddn.com/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png
  [2]: http://onobwtidg.bkt.clouddn.com/metaq.png
  [3]: http://onobwtidg.bkt.clouddn.com/metaq%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.jpg
  [4]: http://onobwtidg.bkt.clouddn.com/broker%E6%8E%A5%E5%8F%97%E6%B6%88%E6%81%AF.jpg 
