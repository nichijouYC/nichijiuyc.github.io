---
title: RPC框架原理
date: 2017-07-10 22:30:19
tags:
---

## RPC
- RPC，即远端过程调用。就是A进程通过网络调用B进程的服务
- 基本原理：客户端上运行的程序在调用对象方法时，底层将针对该方法的调用转换为TCP/HTTP请求，发送到远端服务器，远端服务器监听固定端口，收到这个TCP/HTTP请求后会解析出相关信息，包括客户端想要调用哪个类的哪个方法，参数是什么等，然后进行对应的调用，将调用结果再通过数据包发回即可

<!-- more -->

### RPC的三个要点(代理/通信协议/序列化协议)
1. rpc在调用方法时，需要将调用本地方法转为调用远程方法，所以在具体方法调用的过程中需要实现代理
2. rpc通过网络调用，所以需要解决客户端和服务端之间的网络通信。一般是tcp的短连接或者长连接，需要约定网络通信协议
3. rpc通过网络调用时，客户端要将参数和方法要序列化成二进制才能网络传输，服务端需要反序列化。所以需要约定序列化协议

### 代理
- 对于调用方来说，所存在的只有一个接口，在Java上通过代理的方式实现的底层调用远端方法的逻辑
- 动态代理是指在运行时生成代理类，没有class文件，不需要编译的过程
- 静态代理在编译时已经有代理类，使用效率高
- Java动态代理一般有几种实现方式。一是JDK自带的动态代理。二是CGLIB实现的动态代理，三是可以通过自定义类加载器和asm实现

#### JDK动态代理
- 代理类实现了目标类的接口,被代理类必须要有实现的接口，因为生成代理类的时候根据接口实现所有方法，并且所有方法都是通过反射调用handler里的invoke方法
- 缺点是通过反射运行比较慢，并且会动态生成大量文件在方法区，导致经常fullgc，优点是生成代理类比较快
- 生成的代理类继承Proxy，实现目标类的接口

#### CGLIB动态代理
- CGLIB生成了目标类的子类。优点是执行方法较快运行效率比较高,缺点是生成子类较慢，且不能代理final方法（因为不能通过继承重写）.在目标类加载之后,通过asm构造子类继承目标类的字节码,生成代理类

### 网络通信
- 标准的socket io，使用时很多时候会阻塞，如accept()、read()时都会阻塞。同时启动多个客户端时，后面的客户端会被阻塞在accept()方法中。 这种情况可以给每个客户端都单独分配一个线程，但是这样创建过多的线程和连接，可能会严重影响服务器的性能，并且每个连接不能充分利用，很多时间都是空闲的
- NIO是同步非阻塞，可以避免上述问题。Netty是实现NIO的第三方框架
#### Netty
- Netty的channel在写操作时，可以感知链路网络异常，这时客户端定时的心跳包发送可以保证在客户端及时检测到链接的不可用，然后HSF进行关闭连接操作。服务端也对连接做异常检测，及时关闭不可以用连接
在服务提供者和调用者间有多个服务请求同时调用时会共用同一个长连接，即一个连接交替传输不同请求的字节块。它既避免了反复建立连接开销，也避免了连接的等待闲置从而减少了系统连接总数

### 序列化协议
- 序列化有很多种实现方式：java，hessian，hessian2，json，kyro，protobuf，thrift，xml等
- json：明文结构清晰，可以跨语言，  字节数较大 但比java小  需依赖第三方类库
- java object serializa：java 原生支持，不需要类库， 但无法跨语言 字节数较大
- protobuf：字节数小，适合网络传输，跨语言，   但依赖工具生成代码

## HSF
### 特点
- 服务治理(消费者白名单，限流)
- 泛化调用（不需要二方包接口api，只需要接口名，方法名，参数即可）
- 可以配置多种路由规则（权重规则，同机房规则，动态权重规则，一致性哈希规则）实现负载均衡

### 三要点实现方式
- 代理：JDK动态代理
- 通信协议：Netty
- 序列化：支持java、hessian、hessian2、json、kyro

### 提供服务的流程
- server启动时候向configserver注册
- client启动时候向configserver请求list
- client缓存list，发现不可用的server，从缓存中remove
- configserver通过心跳包维护可用server的list
- list有更新的时候，configserver通过带version的报文通知client更新

### hsf优点
- 服务治理
- 路由规则






